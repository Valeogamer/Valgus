# -*- coding: utf-8 -*-
"""RearFootVarusDATASETS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nEKei0nox0DV1WzJLnSXcWXn9-6D_UiD

# Бинарная классификация

## Вероятностное определение вальгусной деформации заднего отдела стопы с помощью MLP и CNN.

### Подключаем необходимые модули
"""

import tensorflow as tf
from tensorflow.keras import datasets, layers, models
import matplotlib.pyplot as plt
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, classification_report

"""### Получаем доступ к GDrive"""

from google.colab import drive
drive.mount('/content/drive')

"""### Указываем путь к датасету"""

path_data_dir = '/content/drive/MyDrive/FootDataset/data.npy'
path_labels_dir = '/content/drive/MyDrive/FootDataset/labels.npy'

"""### Загружаем датасет"""

data = np.load(path_data_dir, allow_pickle=True)
labels = np.load(path_labels_dir, allow_pickle=True)

"""### Функция отображения

Проверим какие данные, в каком формате загрузили и нуждаются ли данные в стандартизации
"""

def visualization(data_images: np.array, labels=None):
    """
    Визуализция матричного изображения
    """
    plt.imshow(data_images)
    if labels:
        plt.title(f"Метка: {labels}")
    else:
        plt.title("Вывод изображения")
    plt.show()

visualization(data[2], labels[2])

data[0].shape

"""### Разделим данные на обучающую и тестовую выборку"""

test_size = 0.2  # процент тестовой выборки

X_train, X_test, y_train, y_test = train_test_split(data, labels, test_size=test_size, random_state=42)

X_train[0]

"""### Проведем нормализацию

Приведем к виде от 0 до 1
"""

X_train = X_train / 255
X_test = X_test / 255

# проверяем
X_train[0]

"""## Полносвязная нейронная сетка MLP

### Подготовка
"""

classes = ["Overpronation", "Pronation"]

visualization(data[2], classes[labels[2]])

d_h_w_c = data.shape
print(d_h_w_c)
d = d_h_w_c[0] # количество выборки
w = d_h_w_c[1] # ширина
h = d_h_w_c[2] # высота
c = d_h_w_c[3] # количество цветовых каналов

"""### Строим модель"""

h_w_c = data.shape
mlp = models.Sequential([
    layers.Flatten(input_shape = (w, h, 3)),
    layers.Dense(3000, activation='relu'),
    layers.Dense(1000, activation='relu'),
    layers.Dense(len(classes), activation='sigmoid')
])

"""### Компилируем модель"""

mlp.compile(optimizer='SGD',
            loss = 'sparse_categorical_crossentropy',
            metrics=['accuracy'])

"""### Выводим структуру модели (Архитектуру)"""

mlp.summary()

"""### Обучаем модель"""

mlp.fit(X_train, y_train, epochs=5)

"""### Подробный отчет"""

y_pred = mlp.predict(X_test)
y_pred_classes = [np.argmax(element) for element in y_pred]

print('Classification report: \n', classification_report(y_test, y_pred_classes))

"""## Сверточная нейронная сеть (CNN)

### Строим модель
"""

cnn = models.Sequential([
    # cnn
    layers.Conv2D(filters=32, kernel_size=(3, 3),  activation='relu', input_shape=(w, h, 3)), # сверточный слой
    layers.MaxPooling2D((2, 2)),

    layers.Conv2D(filters=64, kernel_size=(3, 3),  activation='relu'), # сверточный слой
    layers.MaxPooling2D((2, 2)),

    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(len(classes), activation='softmax')
])

"""### Компилируем модель"""

cnn.compile(optimizer='adam',
            loss = 'sparse_categorical_crossentropy',
            metrics=['accuracy'])

"""### Выводим структуру модели (Архитектуру)"""

cnn.summary()

"""### Обучаем модель"""

cnn.fit(X_train, y_train, epochs=10)

"""### Проверяем на тестовом наборе"""

cnn.evaluate(X_test, y_test)

"""### Отчет"""

y_pred = cnn.predict(X_test)
y_pred_classes = [np.argmax(element) for element in y_pred]
print('Classification report: \n', classification_report(y_test, y_pred_classes))

y_classes = [np.argmax(element) for element in y_pred]
print('Предсказанная')
y_classes[:5]

print('Оригинальная')
y_test[:5]

def plot_sample(X, y, index):
  """
  Вывод изо и класса
  """
  plt.figure(figsize=(15, 2))
  plt.imshow(X[index])
  plt.xlabel(classes[y[index]])

plot_sample(X_test, y_test, 4)